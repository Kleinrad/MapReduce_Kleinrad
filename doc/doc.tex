\documentclass[12pt, letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage[backend=biber]{biblatex}
\usepackage{float}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage[newfloat]{minted}
\usepackage{caption}
\usepackage{dirtree}
\tolerance=1
\emergencystretch=\maxdimen
\hyphenpenalty=10000
\hbadness=10000
\addbibresource{references.bib}

\newenvironment{code}{\captionsetup{type=listing}}{}
\SetupFloatingEnvironment{listing}{name=Source Code}

\graphicspath{{img/}}

\title{MapReduce‚ÄêSystem (37)}
\author{Fabian Kleinrad (07), 5BHIF}
\date{March 2022}

\begin{document}

\begin{titlepage}
\maketitle
\end{titlepage}

\tableofcontents
\newpage

\section{Introduction}

In this project, the technology MapReduce is being simulated. Thereby a simple system has been developed to imitate the functionality of a MapReduce application. All of the functionality in this project is written with C++17 and compiled with the help of the meson build system\footfullcite{meson}. The communication is based on the TCP protocol and realized using the C++ library asio\footfullcite{asio}.\newline
Furthermore, to increase performance and usability, protocol buffers\footfullcite{protobuf} are utilized. Protocol Buffers enable the serialization of data structures in an efficient manner, which simplifies working with messages sent between parties in the MapReduce system.\newline
To make use of the advantages of a MapReduce architecture, a simple use-case consisting of counting the number of character occurrences in a plain text document has been implemented. This kind of application was chosen due to its simplicity, which enables the focus of this project to stay on MapReduce rather than a test application. 

\section{MapReduce}

MapReduce is a programming model developed to decrease the computation time of large data sets. It was invented by Google, the reason being the need to compute various kinds of derived data. Examples would be inverted indices or representations of the graph structure of web documents. These applications all have simplicity in common. There are no complex operations needed to accomplish said tasks. Furthermore are, these kinds of processes characterized by accepting large amounts of input data and reducing it to a fraction of itself. MapReduce presents a solution to parallelization, fault-tolerance, data distribution, and load balancing. It is based on the principle of map and reduce, which is eponymous for the technology.\footfullcite{mapreducePaper}

\subsection{Input Data}

MapReduce processes unstructured or semi-structured data. The system is designed to accept large amounts of data in bulk. In the first step of the MapReduce process, this data is split into subsets to allow for data distribution. The way this data is divided depends on the implementation and the type of input data present. The result of splitting the raw data is a set of key/value pairs.\footfullcite{uniLeibzigMapReduce}

\subsection{Map}

The map function accepts a set of key/value pairs, with the implementation being provided by the user. The result of this phase is once more a set of key/value pairs. These result pairs represent the significant information contained in the input data. These significant data pairs directly influence the result, and all unneeded information is discarded. The name map stems from assigning a quantity attribute representing the value of the resulting pairs to a quality attribute.\footcite{uniLeibzigMapReduce}\footcite{mapreducePaper}

\subsection{Reduce}

Sorted key/value pairs get passed to the reduce function, which groups and reduces the set of data points. The logic of this grouping functionality depends on the application of MapReduce. For that reason, the reduce function is also implemented by the user.\footcite{uniLeibzigMapReduce}

\pagebreak

\subsection{Additional Phases}

\subsubsection{Shuffle}
In most implementations of a MapReduce model, a shuffle phase is carried out between the map and reduce phase. The shuffle phase sorts the resulting key/value pairs from the mapping phase. This is done to group similar keys into a cluster that can then be reduced by a single worker.\footcite{uniLeibzigMapReduce}\newline

\subsubsection{Combine}
An additional combine phase can be used after mapping to reduce the network traffic. Thereby, the large number of key/value pairs resulting from the mapping phase are reduced before they are transferred over the network. However, because of this local aggregation of data, it is possible to slow down the instead through shuffling optimized process of reducing data.\footfullcite{hadoop}

\section{Classes}

The class structure in this project is oriented in the MapReduce solution Disco\footfullcite{discoDoc}. In contrast to the realization disco provides, only three parties are present in this project. Disco uses a central master to act as an interface between the client and the workers, which in disco are referred to as slaves. Additionally disco has a server role. This server manages a number of workers and acts as an intermediary between the worker and master. However the role of the server has not been realized in this implementation to steer away from high complexity and enable the realization of a reliably working model in the time-span of this project.

\subsection{Master}

The master acts as an interface connecting the clients to workers. Additionally the master acts as the central server accepting and managing all connections. To simplify handling these tasks, the master is supported by the ClientManager and WorkerManager. These run as independent threads and allow for a delimited program structure.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.6\linewidth]{img/Master}
	\caption{Structure of the Master class.}
	\label{fig:classes_Master}
\end{figure}

Figure \ref{fig:classes_Master} depicts the structure of the Master class. The Master contains instances of ClientManager and WorkerManager, which run in separately and take care of the tasks the master needs to handle. This leaves the core master class with an acceptConnection method, which asynchronously accepts asio clients, which are then delegated to either the WorkerManager or ClientManager.    


\subsubsection{ClientManager}

The ClientManager handels MapReduce client connections. Client refers to an human user of the MapReduce system. 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{img/ClientManager}
	\caption{Structure of the ClientManager class.}
	\label{fig:classes_ClientManager}
\end{figure}

In order for the master to be able to add connections, the ClientManager provides a $join$ function. To support disconnecting clients, a $leave$ function is available. Both of these functions take an instance of a connection represented by a shared pointer on a ConnectionObject. By this means the ClientManager can keep track of ongoing client-master connections and acts as an communication interface between them.\newline 
Additionally the $registerJob$ and $sendResult$ function are depicted in figure \ref{fig:classes_ClientManager}. These two functions handle job management on the client side of the master. Thereby ongoing jobs are being tracked and upon finishing the client gets sent the resulting data. Lastly the class contains a $generateID$ function, which is used to generate unique ids to identify clients.

\subsubsection{WorkerManager}

The WorkerManager works analogously to the ClientManager, whereas the WorkerManager handles the master-worker communication. The WorkerManager also provides $join$ and $leave$, which are used by the master to delegate connections. 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\linewidth]{img/WorkerManager}
	\caption{Structure of the WorkerManager class.}
	\label{fig:classes_WorkerManager}
\end{figure}

Similarly to the ClientManager, the WorkerManager provides a $assignJob$ function. This function acts as the interface between the ClientManager and WorkerManger. The functionality of distributing a job received from a client is thereby realized. To allow for results to be forwarded to the WorkerManager, the functions $mapResult$ and $reduceResult$ exist. These methods are used by the ConnectionSession were communication takes place.\newline
To increase fault-tolerance, WorkerManager provides a $reAssignTask$ function, which is used when a worker fails to properly perform its task. The $generateID$ function works the same as in the ClientManager and is used to uniquely identify workers.  

\subsection{Client}

The Client class represents the link between the user and the MapReduce system. It implements a user interface to enable the user to communicate with the system and place job requests. 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.6\linewidth]{img/Client}
	\caption{Structure of the Client class.}
	\label{fig:classes_Client}
\end{figure}

In order to initiate the connection to the master server, the ClientManager implements a $signOn$ function. Similarly the class also provides a $signOff$ function to terminate the connection. The function $sendJob$, which is depicted in figure \ref{fig:classes_Client} is used to place job request. To enable visualization of job results, the functions $printResultsPlain$ as well as $printResultsHistogram$ are implemented by the ClientManager.

\subsection{Worker}

The Worker is the powerhouse of the MapReduce system. It handles the computation of tasks that are assigned by the master. For this purpose the Worker implements the functions $handleMap$ and $handleReduce$, which can theoretically be replaced by any kind of logic accepting and returning the same data types as MapReduce intends. 

\begin{figure}[h]
 	\centering
 	\includegraphics[width=0.8\linewidth]{img/Worker}
 	\caption{Structure of the Worker class.}
 	\label{fig:classes_Worker}
\end{figure}

The $handleMap$ and $handleReduce$ functions take the type of job, data and job id as parameters. Whereas the $handleMap$ function accepts the raw data in the shape of a string, the $handleReduce$ function is provided with a set of key/value pairs.\newline
To control the connection to the master, the functions $signOn$ and $signOff$ are provided which work analogously to the functions in the ClientManager.

\section{Helper Classes}

\subsection{Pipe}

To centralize the asio network connection the pipe class is used. It provides an network interface to simplify sending and receiving messages. Pipe uses a asio socket to transfer messages. Additionally the class ensures the thread safe usage of the socket. 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.55\linewidth]{img/Pipe}
	\caption{Structure of the Pipe class.}
	\label{fig:classes_Pipe}
\end{figure}

\subsection{ConnectionObject}

To represent client and worker connections the ConnectionObject is used. It provides structure for connections and stores important information to handle ongoing connections. 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.6\linewidth]{img/ConnectionObject}
	\caption{Structure of the ConnectionObject class.}
	\label{fig:classes_ConnectionObject}
\end{figure}

To identify a ConnectionObject, it contains an id, as depicted in figure \ref{fig:classes_ConnectionObject}. This id is not unique across all ConnectionObjects, due to the distinction made between worker an client connection. Additionally the ConnectionObject stores information about the state of availability. However this attribute is only used in worker connections.\newline
In an effort to increase fault-tolerance and detect broken connections the ConnectionObject stores the time, when the last message was received. Thereby it enables the server to periodically check connections and end them if no response has been received.

\subsection{ConnectionSession}

The ConnectionSession handles the communication between the master and workers as well as clients.
The basic structure of implementing asio, multi-user communication this way, has been inspired by the asio-documentation\footfullcite{asioMultiuser}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.6\linewidth]{img/ConnectionSession}
	\caption{Structure of the ConnectionSession class.}
	\label{fig:classes_ConnectionSession}
\end{figure}

To start the process of receiving and sending messages the ConnectionSession provides a $start$ function. Additionally the ConnectionSession implements the functions $sendMessage$, $isConnected$ and $closeConnection$ from the ConnectionObject class.  

\pagebreak
\subsection{Job}

The Job class allows for uniform structure when processing jobs.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.6\linewidth]{img/Job}
	\caption{Structure of the Job class.}
	\label{fig:classes_Job}
\end{figure}

Job provides a variety of constructors to simplify using the Job class in all phases of the MapReduce process. To identify jobs it contains an id that is unique across all jobs. Furthermore a job stores information about the type of job and current status. The different states of a job are defined in the $JobStatus$ enum, depicted in figure \ref{fig:classes_JobStatus}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.3\linewidth]{img/JobStatus}
	\caption{Enum containing job states.}
	\label{fig:classes_JobStatus}
\end{figure}

\subsubsection{ActiveJob}

To allow for tasks to be reassigned upon failure, the ActiveJob class provides all information to do so.
Due to the reciprocally relationship between ActiveJob and Job, it is necessary to split the ActiveJob into two classes. The class ActiveJob, depicted in figure \ref{fig:classes_ActiveJob} is the derived from the class ActiveJobStruct, depicted in figure \ref{fig:classes_ActiveJobStruct}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.28\linewidth]{img/ActiveJob}
	\caption{Structure of the ActiveJob class.}
	\label{fig:classes_ActiveJob}
\end{figure}

The class ActiveJobStruct provides the structure of an active job. Thereby information of all phases of the MapReduce process are stored in an ActiveJob. Additionally to the attributes contained in the Job class, it also provides the possibility to store the data each worker is currently processing.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{img/ActiveJobStruct}
	\caption{Structure of the ActiveJobStruct class.}
	\label{fig:classes_ActiveJobStruct}
\end{figure}
\pagebreak

\subsection{MessageQueue}

Due to communication taking place between multiple parties, it is important to serialize the processing of messages. This concept can be realized by using a queue, in this project realized through the MessageQueue class, depicted in figure \ref{fig:classes_MessageQueue}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth]{img/MessageQueue}
	\caption{Structure of the MessageQueue class.}
	\label{fig:classes_MessageQueue}
\end{figure}

To implement the functionality of a queue, MessageQueue uses the queue datatype provided by c++. Additionally the MessageQueue ensures that access to the queue happens in a thread save manner. 

\subsubsection{QueueItem}

To store the data of an item in the queue, the QueueItem class provides the needed structure. 
The QueueItem stores data that can be received by the master from workers.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.55\linewidth]{img/QueueItem}
	\caption{Structure of the QueueItem class.}
	\label{fig:classes_QueueItem}
\end{figure}

\subsection{MessageGenerator}

In an effort to simplify working with protobuf messages, the MessageGenerator provides a variety of functions that return the respective message. 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.95\linewidth]{img/MessageGenerator}
	\caption{Structure of the MessageGenerator class.}
	\label{fig:classes_MessageGenerator}
\end{figure}

\pagebreak
\section{Class-diagram}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\linewidth]{img/ClassDiagram}
	\caption{UML class diagram, representing the structure of this project.}
	\label{fig:classDiagram}
\end{figure}

\section{Network communication}

\subsection{asio}

\subsection{protobuf}

\subsection{Messages}

\subsubsection{Assignment}
The Assignment message is used to assign ids to worker and clients. An Assignment is sent in the ConnectionSession after a new connection gets accepted by the master. It contains the id that the connection partner gets assigned and the type of connection, either client or worker.

\subsubsection{SignOff}
A SignOff message is either sent from a worker or client upon encountering an error which results in the termination of the program. This is performed to let the master know when a client or worker is no longer available. The SignOff message can also be sent from master to client or worker to force them to stop. This behavior can be observed when the master program terminates. A SignOff contains the id of client or worker that is about to disconnect and the respective connection type.

\subsubsection{Confirm}
A Confirm is used the ensure that important messages have been delivered. An example of its application is to confirm that an Assignment has been delivered. This is especially important, because all later communication is based on ids. If a client or worker hasn't been assigned an id, it would not be possible for future messages to be accepted by the master, due to the lack of identification of the sender. 

\subsubsection{TaskMap}
The TaskMap message gets sent from master to worker to assign a task to the respective worker along with the needed information to perform it. The message contains the job id which uniquely identifies the job. This is important information to match the result sent by the worker to the original job. Furthermore the type of job and data is being transferred.

\subsubsection{TaskReduce}
The TaskReduce message works analogously to the TaskMap message. Instead of the data consisting of a string, that being the case with TaskMap, in TaskReduce the data gets transferred in the shape of key/value pairs. 

\subsubsection{ResultMap}
ResultMap is a message that is sent by the worker upon finishing the mapping task. It contains the result of the mapping in the form of key/value pairs. Furthermore it contains the job id, to enable the master to match tasks to jobs.

\subsubsection{ResultReduce}
ResultReduce gets sent by the worker upon finishing the reduce task. The result is transferred in the shape of key/value pairs. Additionally it contains the id of the job. 

\subsubsection{JobRequest}
A JobRequest is sent from client to master. It contains information on the job that is to be performed, along with the data to be processed. Furthermore the client can specify the amount of mapping workers and reducing worker it desires. 

\subsubsection{JobResult}
The JobResult is the reply to the client from the master after finishing the job. It contains the result of the MapReduce operation in the form of key/value pairs.  

\subsubsection{Ping}
The Ping message is used for checking connections. After the master detects a worker being inactive for an extended period of time it sends pings in one second intervals until a reply is received or five pings are sent. If a worker receives a Ping it replies with a Ping message.

\subsection{Implementation}

\section{Usage}
\label{usage}

\subsection{Command Line Arguments}

\subsubsection{Configuration}


\newpage

\section{Project Structure}


% .bib include & references
\newpage

\printbibliography
\end{document}